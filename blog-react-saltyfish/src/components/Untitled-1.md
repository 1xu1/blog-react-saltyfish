## 前言\n最近在工作过程中使用了React的函数式组件写法写了好几个组件，个人认为这种写法十分顺畅舒滑，因此在这记录一下函数式组件的写法和用法。\n## 正文\n- 首先则是给出一个React使用Hook的
一个案例\n``` javascript\nimport React, { useState } from 'react';\n\nfunction Example() {\n  // 声明一个叫 “count” 的 state 变量。\n  // count为状态变量，setCount为更新该状态变量的函数\n  // useState的参数为该状态变量的初始值\n  const [count, setCount] = useState(0);\n\n  // 组件渲染内容\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n- 如上是一个简单的计数器组件，结构简单，采用函数式组件的写法，使用了`useState`这一状态Hook。\n- 全程使用function包裹组件 
，不会涉及到this这一概念，也就避免了this相关的一系列问题\n- 下文主要是对不同的hooks作一下简单介绍\n### useState\n- useState起到了一个创建状态变量的作用\n``` javascript\nconst [state, setState] = useState(initialState);\n```\n- state指向了该状态变量，可以在后续的代码中使用state这一状态变量\n- 当我们需要更新该状态变量的值时，我们就可以用setState这一个函数来更新这一状态变量\n- 与Class类组件的
state不同，this.setState是会自动合并更新对象的，如果要用useState起到同样的自动合并更新对象的效果的话，需要采取如下的写法\n``` javascript\nconst [state, setState] = useState({});\nsetState(prevState => {\n  // 也可以使用 Object.assign\n  return {...prevState, ...updatedValues};\n});\n```\n- 与class组件的setState相同，useState中的setState也是异步函数，因此如果我们想获取setState的回调函数时，
我们在hook的写法中可以用如下写法实现。除此之外，用useEffect这一hook也能实现相同的回调效果。\n``` javascript\n  const [value,setValue] =useState(0)\n  const add= ()=>{\n  new Promise((resolve)=>{\n    setValue((num)=>{\n       resolve(num+1)\n       return num + 1\n    })\n  }).then(res=>{\n     console.log(res)\n     ...\n  })\n}\n```\n- 另外react官方也对该setState做了一个有意思的优化，如 
果你更新 State Hook 后的 state 与当前的 state 相同时，React 将跳过子组件的渲染并且不会触发 effect 的执行。（React 使用 Object.is 比较算法 来比较 state。）\n### useEffect\n``` javascript\nuseEffect(didUpdate);\n```\n- useEffect是一个用于完成副作用函数的hook，其入参为对应的副作用函数didUpdate。\n- 赋值给 useEffect 的函数会在每轮组件渲染完成后执行\n- 当你需要进行一些如改变 DOM、添加订阅、设置
定时器、记录日志以及执行其他各种渲染过程中不允许出现的操作时，就会需要用到这个hook\n- 组件卸载后应当对组件运作途中产生的一些订阅与计时器进行清除，这时候就可以用到useEffect的返回值，返回一个清除函 
数，该清除函数会在组件卸载之前执行。写法如下：\n``` javascript\nuseEffect(() => {\n  const subscription = props.source.subscribe();\n  return () => {\n    // 清除订阅\n    subscription.unsubscribe();\n  };\n});\n```\n- 我们也可以对副作用函数的执行增加一些依赖项，这时候我们可以对useEffect的第二个入参传入依赖项来达成目的\n``` javascript\nuseEffect(\n  () => {\n    const subscription = props.source.subscribe();\n    return () => {\n      subscription.unsubscribe();\n    };\n  },\n  [props.source],\n);\n```\n- 这时候只有props.source这一依赖项发生变化时才会执行副作用函数\n- 如果你想要副
作用函数只在挂载和卸载组件的时候执行一次（就像compnentDidMount以及componentWillUnmount一样），只需要给第二个入参传入空数组`[]`即可\n- 从概念上来说它表现为：所有 effect 函数中引用的值都应该出现在依
赖项数组中。\n